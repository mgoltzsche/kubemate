package passwordgen

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

var wordCountRegex = regexp.MustCompile(`^([A-Z]+)\t([0-9]+)$`)

const (
// normalizeWeight = 1000000
)

func TestGenerateBuildMapping(t *testing.T) {
	words, err := loadCommonWords()
	require.NoError(t, err)
	bigrams := bigramPrefixes(words)
	trigrams := weightedTrigramMap(words)
	generateGoMappingFile(bigrams, trigrams, "ngrammapping.gen.go")
}

func loadCommonWords() (map[string]uint64, error) {
	reader, err := os.Open("norvig-com-google-books-common-words.txt")
	if err != nil {
		return nil, err
	}
	/*resp, err := http.Get("http://norvig.com/google-books-common-words.txt")
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("cannot download common english words from norvig.com: status %s", resp.Status)
	}
	reader := resp.Body*/
	defer reader.Close()
	r := map[string]uint64{}
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.SplitN(line, "\t", 2)
		if len(parts) == 2 {
			word := strings.ToLower(parts[0])
			count, err := strconv.ParseUint(parts[1], 10, 64)
			if err != nil {
				return nil, err
			}
			r[word] = count
		}
	}
	if err = scanner.Err(); err != nil {
		return nil, err
	}
	return r, nil
}

func bigramPrefixes(words map[string]uint64) []bigram {
	// Collect bigrams
	m := map[string]uint64{}
	for k, v := range words {
		if len(k) >= 2 {
			bigram := k[:2]
			m[bigram] = m[bigram] + v
		}
	}
	// Collect highest weight for normalization
	var highestWeight uint64
	for _, v := range m {
		if highestWeight < v {
			highestWeight = v
		}
	}
	// Normalize weight, map and sort
	r := make([]bigram, 0, len(m))
	for k, v := range m {
		//weight := int(math.Round(float64(v) / float64(highestWeight) * normalizeWeight))
		weight := int(v)
		if weight > 7 {
			r = append(r, bigram{
				Bigram: k,
				Weight: weight,
			})
		}
	}
	sort.Slice(r, func(i, j int) bool {
		return r[i].Weight > r[j].Weight
	})
	return r
}

func weightedTrigramMap(words map[string]uint64) map[string][]weightedChar {
	// Collect ngrams
	wm := map[string]map[byte]uint64{}
	for k, v := range words {
		if len(k) > 3 {
			for i := 2; i < len(k); i++ {
				bigram := k[i-2 : i]
				successor := k[i]
				m := wm[bigram]
				if m == nil {
					m = map[byte]uint64{}
					wm[bigram] = m
				}
				m[successor] = m[successor] + v
			}
		}
	}
	// Normalize weight
	for _, successors := range wm {
		var highestWeight uint64
		for _, v := range successors {
			if highestWeight < v {
				highestWeight = v
			}
		}
		for k, v := range successors {
			//weight := uint64(math.Round(float64(v) / float64(highestWeight) * normalizeWeight))
			weight := v
			successors[k] = weight
		}
	}
	// Map and sort
	r := make(map[string][]weightedChar, len(wm))
	for bigram, successors := range wm {
		wc := make([]weightedChar, 0, len(successors))
		for k, v := range successors {
			if v > 0 {
				wc = append(wc, weightedChar{Char: k, Weight: int(v)})
			}
		}
		if len(wc) > 0 {
			sort.Slice(wc, func(i, j int) bool {
				return wc[i].Weight > wc[j].Weight
			})
			r[bigram] = wc
		}
	}
	return r
}

func generateGoMappingFile(bigrams []bigram, trigramMapping map[string][]weightedChar, file string) error {
	var sb strings.Builder
	sb.WriteString("// Code generated by test. DO NOT EDIT.\n\npackage passwordgen\n\nvar bigrams = []bigram{\n")
	for _, bigram := range bigrams {
		if _, ok := trigramMapping[bigram.Bigram]; ok {
			sb.WriteString(fmt.Sprintf("\t{Bigram: %q, Weight: %d},\n", bigram.Bigram, bigram.Weight))
		}
	}
	sb.WriteString("}\n\n")
	sb.WriteString("var ngramMapping = map[string][]weightedChar{\n")
	keys := make([]string, 0, len(trigramMapping))
	for bigram := range trigramMapping {
		keys = append(keys, bigram)
	}
	sort.Strings(keys)
	for _, bigram := range keys {
		sb.WriteString(fmt.Sprintf("\t%q: []weightedChar{\n", bigram))
		for _, c := range trigramMapping[bigram] {
			sb.WriteString(fmt.Sprintf("\t\t\t{Char: '%s', Weight: %d},\n", string([]byte{c.Char}), c.Weight))
		}
		sb.WriteString("\t},\n")
	}
	sb.WriteString("}\n")
	return os.WriteFile(file, []byte(sb.String()), 0644)
}
